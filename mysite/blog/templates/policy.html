{% extends "base.html" %} 
{% block content %}
<style>
    body {
        font-family: "Roboto", sans-serif;
        font-size: 18px;
        background-color: #fdfdfd;
    }
    
    .head_text {
        color: white;
    }
    .card {
        box-shadow: 0 16px 48px #E3E7EB;
    }
    .custom-padding-top-2 {
        padding-top: 2%;
    }
</style>

<header class="masthead">
    <div class="overlay"></div>
    <div class="container">
        <div class="row">
            <div class=" col-md-8 col-md-10 mx-auto">
                <div class="site-heading">
                    <h3 class=" site-heading my-4 mt-3 text-white">Политика и правила этого сайта</h3>
                    <h5 class="text-light">
                    <p> Functions have been divided into abstract </p>
                    patterns suitable for most use cases.
                    As more and more possible cases are discussed
                    One problem emerged - the templates became cumbersome
                    and did not expand. This limited their use
                    in many real world applications.
                    <p> Class-based views are made to be solved </p>
                    the same problem as general view functions: to simplify programming.
                    However, this was implemented using admixtures: class sets,
                    which make general class views more extensible, and
                    flexible to customize than the corresponding functions.
                    <p> If you've used a function successfully before, and have </p>
                    enough of their possibilities, you should not be general
                    class views as another equivalent troubleshooting method.
                    Try to take a fresh look at the times when this approach was taken
                    would be more appropriate.
                    <p> If you've used a function successfully before, and have </p>
                    The Django toolkit for base classes and mixins allows
                    to make generic class views as flexible as possible,
                    with multiple Hooks like default attribute values ​​or
                    base method implementations that often don't need to be
                    overwritten on a case by case basis.
                    For example, instead of using the base class attribute form_class,
                    the implementation calls the get_form method, which calls the get_form_class method,
                    which in turn simply returns the form_class base class attribute by default.
                    <p> Class-based views are made to be solved </p>
                    This gives you the option to specify which form is to be used in both the attribute and
                    and dynamically in the overwritten method. At first glance, such behavior
                    causes unnecessary complexity in simple cases, but it is necessary
                    covering the largest possible use cases.
                    </h5>
                </div>
            </div>
        </div>
    </div>
</header>
    <div class="row">
        <!-- Blog Entries Column -->
        <div class="col-md-8 mt-3 left custom-padding-top-2">
            {% for post in post_list %}
            <div class="card mb-4">
                <div class="card-body">
                    <h2 class="card-title">{{ post.title }}</h2>
                    <p class="card-text text-muted h6">{{ post.author }} | {{ post.created_on}} </p>
                    <p class="card-text">{{post.content|slice:":200" }}</p>
                    <a href="{% url 'post_detail' post.slug  %}" class="btn btn-dark">Читать ...</a>
                </div>
            </div>
            {% endfor %}
            {% block footer %} {% include 'footer.html' %} {% endblock footer %}
        </div>
    </div>
</div>
{%endblock%}
